function users(root, args, context) {
    return context.prisma.users()
}



function projects(parent, args, context){
    return context.prisma.projects();
}



function mediaItems(root, args, context) {
    
    console.log(context.prisma.exists)
    return context.prisma.mediaItems()
}
 

// If you look at the autogenerated PrismaSchema
// Since Type Project returns another custom type, (essentially... project_media: Media_Item) 
// SPECIFICALLY: 
// project_media(where: Media_ItemWhereInput, orderBy: Media_ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media_Item!]
// $where argument, expects Media_ItemWhereInput input type
// Input type Media_ItemWhereInput has the actual properties I want
// i.e. those defined in the datamodel.prisma file plus many more auto generated
/* type Media_Item {
  id: ID! @id
  banner_image_url: String
  video_url: String
} 
*/
// 




// QUERY
// mediaItem(where: Media_ItemWhereUniqueInput!): Media_Item
// 
// INPUT
/* Input Media_ItemWhereUniqueInput {
    id: ID
    }
*/
//


// Resolver function name (async function "") must match query defined in .src/schema.graphql
// The function name accessed on context.prisma must match query defined in
async function returnMediaItem(root, args, context) {
    console.log(args)
    
    const Media_ItemWhereInputVariable = args ? {
        ...args.where
    } : {}
    

    console.log(Media_ItemWhereInputVariable)

    // Defined in the schema.graphql file

// $VAR = {id: #####}
// mediaItems({"where": $VAR})
    const mediaItem = await context.prisma.mediaItems({"where": Media_ItemWhereInputVariable})    //this should be accessing arguments on Media_Item type directly (so id: ID; video_url: string, NOT "where": {})


    console.log("Just ran the function")

    return mediaItem
}


// At its core this is referencing type Query in the autogenerated PrismaSchema
// projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
// $where argument expects ProjectWhereInput type also declared in PrismaSchema
// ProjectWhereInput has a parameter 
// avi_roles_on_project: Avi_RolesWhereInput
// this destructuring will allow argument structure of:
// {
//     "rolesOfInterest": {
//       "avi_gaffer": false
//     }
//   } 
// args returns data in the format { where: {"avi_gaffer": true} }
// hence, args.where gets me the properties of interest
// then I submit the query as per the spec -- projects(where:ProjectWhereInput)
async function filterProjectsByRole(parent, args, context, info){
    console.log(args)

    const ProjectWhereInput = args ? {
        "avi_roles_on_project": {...args.where}
    } : {} 

    console.log(ProjectWhereInput)
    
    const filteredProjects = await context.prisma.projects({"where": ProjectWhereInput})
    return filteredProjects    
}



module.exports = {
    users,
    projects,
    mediaItems,
    filterProjectsByRole
}